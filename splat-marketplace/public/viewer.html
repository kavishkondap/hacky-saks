<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>WebXR Splat Viewer + Capture</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Self-hosted scripts so COEP/COOP don't block them -->
    <script src="/vendor/aframe.min.js"></script>
    <script src="/vendor/aframe-gaussian-splatting.js"></script>

    <style>
      html, body { margin:0; height:100%; background:#000; }
      .hud {
        position: fixed; left: 8px; bottom: 8px; right: 8px; z-index: 20;
        background: rgba(0,0,0,.55); color: #fff; padding: 8px 10px; border-radius: 10px;
        font: 12px/1.45 ui-monospace, SFMono-Regular, Menlo, monospace;
      }
      .row { display:flex; gap:8px; flex-wrap: wrap; align-items: center; margin: 4px 0; }
      .mono { white-space: pre-wrap; }
      .ok { color:#9fe; } .warn { color:#ff9; } .err { color:#f99; }
      button { cursor:pointer; }
    </style>
  </head>
  <body>
    <div class="hud">
      <div class="row">Hold <b>A</b> on the right controller to record. Release to stop.</div>
      <div id="status" class="row mono ok">idle</div>
      <div class="row"><button id="desktopTest">Desktop test (hold mouse)</button></div>
      <div id="result" class="row mono"></div>
    </div>

    <a-scene renderer="antialias: false" stats>
      <a-entity id="sounds" sound="src: oh-my-god-meme.mp3"></a-entity>

      <!-- Lights + sky so you always see *something* -->
      <a-entity light="type: ambient; color: #BBB; intensity: 0.8"></a-entity>
      <a-entity light="type: directional; color: #FFF; intensity: 0.9" position="1 3 -2"></a-entity>
      <a-sky color="#111"></a-sky>

      <!-- Camera rig -->
      <a-entity id="rig" position="0 1.6 0">
        <a-entity id="camera" camera look-controls wasd-controls></a-entity>
      </a-entity>

      <!-- Visual sanity check (use flat shader so lights aren’t required) -->
      <a-entity id="rotating-entity" position="0 1.6 -2"
                animation="property: rotation; to: 0 360 0; dur: 10000; easing: linear; loop: true">
        <a-sphere position="0 0 0.5" radius="0.5" color="#FFFFFF" material="shader: flat"></a-sphere>
        <a-sphere position="0 0 -0.5" radius="0.5" color="#EF2D5E" material="shader: flat"></a-sphere>
      </a-entity>

      <!-- Controllers -->
      <a-entity id="right-controller" oculus-touch-controls="hand: right" control-logic></a-entity>

      <!-- Gaussian splat (underscore attribute!) -->
      <a-entity id="splat-viewer"
                position="0 1.5 -2" rotation="0 0 0" scale="1 1 1"
                gaussian_splatting="src: /public/train.splat;">
      </a-entity>
    </a-scene>

    <script>
      // If ?src= is provided, use it as-is (absolute or relative URL)
      (function () {
        const params = new URLSearchParams(window.location.search);
        const el = document.getElementById('splat-viewer');
        if (params.has('src')) {
          const sourcePath = params.get('src');           // e.g. "public/train.splat"
          el.setAttribute('gaussian_splatting', `src: https://calhacks-hacky-saks.s3.us-east-2.amazonaws.com/${sourcePath};`);
        }
        if (params.has('rot')) {
          const rotation = params.get('rot');
          el.setAttribute('rotation', rotation);
        }
        if (params.has('pos')) {
          const position = params.get('pos');
          el.setAttribute('position', position);
        }
      })();

      const statusEl = document.getElementById('status');
      const resultEl = document.getElementById('result');
      function status(msg, cls='ok'){ statusEl.className = 'row mono '+cls; statusEl.textContent = msg; }

      function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(String(reader.result).split(',')[1]||'');
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }

      // --- Capture logic (unchanged) ---
      AFRAME.registerComponent('control-logic',{
        init: function () {
          this.logThumbstick = this.logThumbstick.bind(this);
          this.logTrigger = this.logTrigger.bind(this);
          this.logAbutton = this.logAbutton.bind(this);
          this.logBbutton = this.logBbutton.bind(this);
          this.el.addEventListener('thumbstickmoved', this.logThumbstick);
          this.el.addEventListener('triggerdown', this.logTrigger);
          this.el.addEventListener('abuttondown', this.logAbutton);
          this.el.addEventListener('bbuttondown', this.logBbutton);

        },
        logAbutton: function (evt) {
          document.querySelector('#rig').object3D.position.y -= 0.1;
        },
        logBbutton: function (evt) {
          document.querySelector('#rig').object3D.position.y += 0.1;
        },
        logTrigger: function (evt) {
          document.querySelector('#rotating-entity').object3D.position.y += 0.1;
          var entity = document.querySelector('#sounds');
          entity.components.sound.playSound();
        },
        logThumbstick: function (evt) {
          xdelta = evt.detail.x;
          zdelta = evt.detail.y;

          document.querySelector('#rig').object3D.position.x += xdelta * 0.02;
          document.querySelector('#rig').object3D.position.z += zdelta * 0.02;


        }
      });

      // Desktop test button
      (function() {
        const btn = document.getElementById('desktopTest');
        let rec=null, stream=null, chunks=[], screenshotBlob=null;
        btn.onmousedown = async () => {
          const scene = document.querySelector('a-scene');
          const canvas = scene.canvas || scene.renderer?.domElement;
          screenshotBlob = await new Promise(res => canvas.toBlob(res, 'image/png'));
          try { stream = await navigator.mediaDevices.getUserMedia({ audio: true }); }
          catch (e) { status('mic denied (desktop test)', 'err'); return; }
          chunks=[]; rec = new MediaRecorder(stream, { mimeType: 'audio/webm' });
          rec.ondataavailable = e => { if (e.data.size) chunks.push(e.data); };
          rec.start(); status('recording… (release mouse to stop)');
        };
        btn.onmouseup = async () => {
          if (!rec) return;
          await new Promise(r => { rec.onstop = r; rec.stop(); });
          stream.getTracks().forEach(t => t.stop());
          const audioBlob = new Blob(chunks, { type:'audio/webm' });

          let transcript=''; try{
            const f = new FormData(); f.append('audio', audioBlob, 'clip.webm');
            const r = await fetch('/api/asr', { method:'POST', body:f });
            const j = await r.json(); if(!r.ok) throw new Error(j.error||'asr_failed');
            transcript = j.text||'';
          }catch(e){ status('Fish STT failed: '+e.message,'err'); }

          try{
            const b64 = await blobToBase64(screenshotBlob);
            const r = await fetch('/api/claude', {
              method:'POST', headers:{'Content-Type':'application/json'},
              body: JSON.stringify({ transcript, image_base64: b64, prompt: 'Describe key details and insights.' })
            });
            const j = await r.json(); if(!r.ok) throw new Error(j.error||'claude_failed');
            window.lastClaudeOutput = j.output||''; resultEl.textContent = window.lastClaudeOutput; status('done.');
          }catch(e){ status('Claude failed: '+e.message,'err'); }
        };
        btn.onmouseleave = btn.onmouseup;
      })();

      // Helpful console diagnostics
      window.addEventListener('error', (e) => console.error('Viewer error:', e.error || e.message));
      AFRAME.scenes && AFRAME.scenes[0]?.addEventListener('loaded', () => console.log('A-Frame scene loaded'));
    </script>
  </body>
</html>
